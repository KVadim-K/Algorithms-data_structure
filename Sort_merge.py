def merge_sort(arr):
    if len(arr) <= 1:  # Если массив содержит 0 или 1 элемент, он уже отсортирован, поэтому он просто возвращается.
        return arr

    # Разделяем массив на две половины
    mid = len(arr) // 2  # Находим середину массива.
    left_half = merge_sort(arr[:mid])  # Рекурсивно сортируем левую половину массива.
    right_half = merge_sort(arr[mid:])  # Рекурсивно сортируем правую половину массива.

    # Слияние отсортированных половин
    return merge(left_half, right_half)

def merge(left, right):
    result = []  # Создаем пустой список для хранения результатов слияния.
    i = j = 0  # Инициализируем индексы для отслеживания текущей позиции в списках `left` и `right`.

    # Объединяем два списка в один, выбирая наименьший элемент
    while i < len(left) and j < len(right):  # Пока не пройдем все элементы в одном из списков, продолжается слияние.
        if left[i] < right[j]:  # Сравниваем текущие элементы из `left` и `right`.
            result.append(left[i])  # Если элемент из `left` меньше, добавляем его в `result` и увеличиваем `i`.
            i += 1
        else:
            result.append(right[j])  # Иначе, добавляем элемент из `right` в `result` и увеличиваем `j`.
            j += 1

    # Добавляем оставшиеся элементы
    result.extend(left[i:])  # Добавляем оставшиеся элементы из `left`, если они есть.
    result.extend(right[j:])  # Добавляем оставшиеся элементы из `right`, если они есть.

    return result  # Возвращаем отсортированный список.

# Пример использования
arr = [38, 27, 43, 3, 9, 82, 10]
sorted_arr = merge_sort(arr)
print("Отсортированный список:", sorted_arr)
